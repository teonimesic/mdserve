import { useState, useEffect, useMemo, useRef } from 'react'
import { useTheme } from './hooks/useTheme'
import { useFolderState } from './hooks/useFolderState'
import { useSidebarResize } from './hooks/useSidebarResize'
import { useSidebarCollapse } from './hooks/useSidebarCollapse'
import { ThemeModal } from './components/ThemeModal'
import { ThemeToggle } from './components/ThemeToggle'
import { SidebarToggle } from './components/SidebarToggle'
import { SidebarResizeHandle } from './components/SidebarResizeHandle'
import { FileTree } from './components/FileTree'
import { MarkdownContent } from './components/MarkdownContent'
import { buildFileTree, type ApiFile } from './utils/fileTree'
import './App.css'
import './CodeBlockEnhancements.css'

function App() {
  const { theme, setTheme, isThemeModalOpen, openThemeModal, closeThemeModal } = useTheme()
  const { isExpanded, toggleFolder, expandFolder } = useFolderState()
  const { width, setWidth, isResizing, startResizing, stopResizing } = useSidebarResize()
  const { isCollapsed, toggle: toggleSidebar, collapsedWidth } = useSidebarCollapse()
  const [files, setFiles] = useState<ApiFile[]>([])
  const [content, setContent] = useState('')
  const [currentPath, setCurrentPath] = useState('')

  const fileTree = useMemo(() => buildFileTree(files), [files])
  const sidebarRef = useRef<HTMLDivElement>(null)
  const contentRef = useRef<HTMLDivElement>(null)
  const startWidthRef = useRef(width)

  useEffect(() => {
    // Fetch file list
    fetch('/api/files')
      .then(res => res.json())
      .then(data => {
        setFiles(data.files)
        // Check if there's a file path in the URL hash
        const hash = window.location.hash.slice(1) // Remove the '#' prefix
        if (hash) {
          // Try to load the file from the URL
          const fileExists = data.files.some((f: ApiFile) => f.path === hash)
          if (fileExists) {
            loadFile(hash)
          } else if (data.files.length > 0) {
            // Fall back to first file if the URL file doesn't exist
            loadFile(data.files[0].path)
          }
        } else if (data.files.length > 0) {
          // No URL hash, load first file
          loadFile(data.files[0].path)
        }
      })
  }, [])

  useEffect(() => {
    // Setup WebSocket for live reload
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
    const ws = new WebSocket(`${protocol}//${window.location.host}/ws`)

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data)
      if (message.type === 'Reload') {
        // Reload current file
        if (currentPath) {
          loadFile(currentPath)
        }
        // Refresh file list
        fetch('/api/files')
          .then(res => res.json())
          .then(data => {
            setFiles(data.files)
          })
      } else if (message.type === 'FileRenamed') {
        // Handle file rename
        if (currentPath === message.old_name) {
          loadFile(message.new_name)
        }
        // Refresh file list
        fetch('/api/files')
          .then(res => res.json())
          .then(data => {
            setFiles(data.files)
          })
      } else if (message.type === 'FileRemoved') {
        // Handle file removal
        if (currentPath === message.name) {
          // Load first file if current was removed
          fetch('/api/files')
            .then(res => res.json())
            .then(data => {
              setFiles(data.files)
              if (data.files.length > 0) {
                loadFile(data.files[0].path)
              }
            })
        }
      }
    }

    ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }

    ws.onclose = () => {
      console.log('WebSocket closed, reconnecting in 1s...')
      setTimeout(() => {
        window.location.reload()
      }, 1000)
    }

    return () => {
      ws.close()
    }
  }, [currentPath])

  const loadFile = (path: string) => {
    fetch(`/api/files/${path}`)
      .then(res => res.json())
      .then(data => {
        setContent(data.html)
        setCurrentPath(path)
        // Update URL hash to reflect current file
        window.location.hash = path
        // Auto-expand folders containing the active file
        const parts = path.split('/')
        for (let i = 1; i < parts.length; i++) {
          const folderPath = parts.slice(0, i).join('/')
          expandFolder(folderPath)
        }
      })
  }

  const handleResizeStart = () => {
    startResizing()
    startWidthRef.current = width
    if (sidebarRef.current) sidebarRef.current.classList.add('resizing')
    if (contentRef.current) contentRef.current.classList.add('resizing')
  }

  const handleResize = (deltaX: number) => {
    if (isResizing) {
      const newWidth = startWidthRef.current + deltaX
      setWidth(newWidth, false)
    }
  }

  const handleResizeEnd = () => {
    stopResizing()
    if (sidebarRef.current) sidebarRef.current.classList.remove('resizing')
    if (contentRef.current) contentRef.current.classList.remove('resizing')
  }

  // Update CSS custom properties based on sidebar state
  useEffect(() => {
    const currentWidth = isCollapsed ? collapsedWidth : width
    document.documentElement.style.setProperty('--sidebar-width', `${currentWidth}px`)
  }, [width, isCollapsed, collapsedWidth])

  // Initialize Mermaid
  useEffect(() => {
    mermaid.initialize({
      startOnLoad: false,
      theme: theme === 'dark' || theme.includes('mocha') || theme.includes('macchiato') ? 'dark' : 'default',
      securityLevel: 'loose',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif',
      flowchart: { useMaxWidth: true, htmlLabels: true },
      sequence: { useMaxWidth: true },
      gantt: { useMaxWidth: true },
    })
  }, [theme])

  // Process content: syntax highlighting, mermaid, and code enhancements
  useEffect(() => {
    if (!content || !contentRef.current) return

    const contentElement = contentRef.current

    // 1. Transform mermaid code blocks into diagrams
    const mermaidBlocks = contentElement.querySelectorAll('pre > code.language-mermaid')
    mermaidBlocks.forEach((codeElement, index) => {
      const preElement = codeElement.parentElement
      if (preElement) {
        const mermaidCode = codeElement.textContent || ''
        const mermaidDiv = document.createElement('div')
        mermaidDiv.className = 'mermaid-wrapper'
        mermaidDiv.innerHTML = `<div class="mermaid" id="mermaid-${Date.now()}-${index}">${mermaidCode}</div>`
        preElement.replaceWith(mermaidDiv)
      }
    })

    // Render mermaid diagrams
    mermaid.run({ querySelector: '.mermaid' }).catch(err => {
      console.error('Mermaid rendering error:', err)
    })

    // 2. Apply Prism syntax highlighting to all code blocks (except mermaid)
    const codeBlocks = contentElement.querySelectorAll('pre > code[class*="language-"]:not(.language-mermaid)')
    codeBlocks.forEach((codeElement) => {
      Prism.highlightElement(codeElement as HTMLElement)
    })

    // 3. Add copy buttons and line number toggles to code blocks
    const preElements = contentElement.querySelectorAll('pre:has(> code[class*="language-"]):not(:has(.code-block-header))')
    preElements.forEach((preElement: Element) => {
      const codeElement = preElement.querySelector('code')
      if (!codeElement) return

      const classes = codeElement.className.split(' ')
      const languageClass = classes.find(cls => cls.startsWith('language-'))
      const language = languageClass ? languageClass.replace('language-', '') : 'text'

      // Create wrapper
      const wrapper = document.createElement('div')
      wrapper.className = 'code-block-wrapper'

      // Create header with controls
      const header = document.createElement('div')
      header.className = 'code-block-header'

      const languageLabel = document.createElement('span')
      languageLabel.className = 'code-block-language'
      languageLabel.textContent = language

      const actions = document.createElement('div')
      actions.className = 'code-block-actions'

      // Line numbers toggle button
      const lineNumbersBtn = document.createElement('button')
      lineNumbersBtn.className = 'code-block-btn'
      lineNumbersBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><line x1="4" y1="3" x2="12" y2="3"/><line x1="4" y1="8" x2="12" y2="8"/><line x1="4" y1="13" x2="12" y2="13"/><circle cx="1.5" cy="3" r="0.5" fill="currentColor"/><circle cx="1.5" cy="8" r="0.5" fill="currentColor"/><circle cx="1.5" cy="13" r="0.5" fill="currentColor"/></svg>'
      lineNumbersBtn.title = 'Toggle line numbers'

      // Restore line numbers state from sessionStorage
      const lineNumbersEnabled = sessionStorage.getItem('code-line-numbers') === 'true'

      lineNumbersBtn.onclick = () => {
        preElement.classList.toggle('line-numbers')
        const hasLineNumbers = preElement.classList.contains('line-numbers')
        lineNumbersBtn.classList.toggle('active', hasLineNumbers)
        // Save state to sessionStorage
        sessionStorage.setItem('code-line-numbers', hasLineNumbers.toString())
        Prism.highlightElement(codeElement as HTMLElement)
      }

      // Copy button
      const copyBtn = document.createElement('button')
      copyBtn.className = 'code-block-btn'
      copyBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="8" height="10" rx="1"/><path d="M8 4V2a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-2"/></svg>'
      copyBtn.title = 'Copy code'
      copyBtn.onclick = async () => {
        try {
          await navigator.clipboard.writeText(codeElement.textContent || '')
          copyBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3,8 6,11 13,4"/></svg>'
          copyBtn.classList.add('copied')
          setTimeout(() => {
            copyBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="8" height="10" rx="1"/><path d="M8 4V2a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-2"/></svg>'
            copyBtn.classList.remove('copied')
          }, 2000)
        } catch (err) {
          console.error('Failed to copy:', err)
        }
      }

      actions.appendChild(lineNumbersBtn)
      actions.appendChild(copyBtn)
      header.appendChild(languageLabel)
      header.appendChild(actions)

      // Wrap the pre element
      preElement.parentNode?.insertBefore(wrapper, preElement)
      wrapper.appendChild(header)
      wrapper.appendChild(preElement)

      // Apply saved line numbers state
      if (lineNumbersEnabled) {
        preElement.classList.add('line-numbers')
        lineNumbersBtn.classList.add('active')
      }
      Prism.highlightElement(codeElement as HTMLElement)
    })
  }, [content, theme])

  // Make todo checkboxes interactive
  useEffect(() => {
    if (!content || !contentRef.current || !currentPath) return

    const contentElement = contentRef.current

    // Find all task list checkboxes
    const checkboxes = contentElement.querySelectorAll('input[type="checkbox"]')

    checkboxes.forEach((checkbox, index) => {
      const inputElement = checkbox as HTMLInputElement

      // Remove existing listeners to avoid duplicates
      const newCheckbox = inputElement.cloneNode(true) as HTMLInputElement
      inputElement.replaceWith(newCheckbox)

      // Add click handler
      newCheckbox.addEventListener('click', async (e) => {
        e.preventDefault()
        const checked = newCheckbox.checked

        try {
          // Toggle the checkbox optimistically
          newCheckbox.checked = !checked

          // Send update to backend
          const response = await fetch(`/api/todos/${currentPath}`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              checkbox_index: index,
              checked: !checked,
            }),
          })

          if (!response.ok) {
            // Revert on error
            newCheckbox.checked = checked
            console.error('Failed to update checkbox')
          }
          // The WebSocket will handle the reload and re-render
        } catch (error) {
          // Revert on error
          newCheckbox.checked = checked
          console.error('Failed to update checkbox:', error)
        }
      })
    })
  }, [content, currentPath])

  return (
    <div className={`app ${isCollapsed ? 'sidebar-collapsed' : ''}`}>
      <SidebarToggle isCollapsed={isCollapsed} onClick={toggleSidebar} />
      <ThemeToggle onClick={openThemeModal} />
      <ThemeModal
        isOpen={isThemeModalOpen}
        currentTheme={theme}
        onClose={closeThemeModal}
        onSelectTheme={setTheme}
      />
      <div ref={sidebarRef} className="sidebar">
        <div className="sidebar-header"></div>
        <div className="sidebar-content">
          <FileTree
            nodes={fileTree}
            currentPath={currentPath}
            onFileSelect={loadFile}
            isExpanded={isExpanded}
            onToggleFolder={toggleFolder}
          />
        </div>
        {!isCollapsed && (
          <SidebarResizeHandle
            onResize={handleResize}
            onResizeStart={handleResizeStart}
            onResizeEnd={handleResizeEnd}
          />
        )}
      </div>
      <div ref={contentRef} className="content">
        <div dangerouslySetInnerHTML={{ __html: content }} />
      </div>
    </div>
  )
}

export default App
