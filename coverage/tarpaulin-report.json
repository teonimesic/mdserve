{"files":[{"path":["/","Users","stefano","Documents","mdserve","build.rs"],"content":"use std::process::Command;\nuse std::path::Path;\n\nfn main() {\n    // Build the React frontend\n    let frontend_dir = Path::new(\"frontend\");\n\n    // Check if frontend directory exists\n    if !frontend_dir.exists() {\n        println!(\"cargo:warning=Frontend directory not found, skipping frontend build\");\n        return;\n    }\n\n    // Install dependencies if node_modules doesn't exist\n    let node_modules = frontend_dir.join(\"node_modules\");\n    if !node_modules.exists() {\n        println!(\"cargo:warning=Installing frontend dependencies...\");\n        let npm_install = Command::new(\"npm\")\n            .arg(\"install\")\n            .current_dir(frontend_dir)\n            .status()\n            .expect(\"Failed to run npm install\");\n\n        if !npm_install.success() {\n            panic!(\"npm install failed\");\n        }\n    }\n\n    // Build the frontend\n    println!(\"cargo:warning=Building frontend...\");\n    let npm_build = Command::new(\"npm\")\n        .arg(\"run\")\n        .arg(\"build\")\n        .current_dir(frontend_dir)\n        .status()\n        .expect(\"Failed to run npm run build\");\n\n    if !npm_build.success() {\n        panic!(\"npm run build failed\");\n    }\n\n    // Rerun if frontend source files change\n    println!(\"cargo:rerun-if-changed=frontend/src\");\n    println!(\"cargo:rerun-if-changed=frontend/package.json\");\n    println!(\"cargo:rerun-if-changed=frontend/vite.config.ts\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stefano","Documents","mdserve","src","app.rs"],"content":"use anyhow::Result;\nuse axum::{\n    extract::{\n        ws::{Message, WebSocket},\n        Path as AxumPath, State, WebSocketUpgrade,\n    },\n    http::{header, StatusCode, Uri},\n    response::{IntoResponse, Json, Response},\n    routing::{get, put},\n    Router,\n};\nuse futures_util::{SinkExt, StreamExt};\nuse notify::{Config, Event, RecommendedWatcher, RecursiveMode, Watcher};\nuse rust_embed::RustEmbed;\nuse serde::{Deserialize, Serialize};\nuse std::{\n    fs,\n    net::Ipv6Addr,\n    path::{Path, PathBuf},\n    sync::Arc,\n    time::SystemTime,\n};\nuse tokio::{\n    net::TcpListener,\n    sync::{broadcast, mpsc, Mutex},\n};\nuse tower_http::cors::CorsLayer;\n\n#[derive(RustEmbed)]\n#[folder = \"frontend/dist\"]\nstruct FrontendAssets;\n\nconst RESCAN_DELAY_MS: u64 = 200;\n\ntype SharedMarkdownState = Arc<Mutex<MarkdownState>>;\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\n#[serde(tag = \"type\")]\npub enum ClientMessage {\n    Ping,\n    RequestRefresh,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(tag = \"type\")]\npub enum ServerMessage {\n    Reload,\n    Pong,\n    FileAdded { name: String },\n    FileRenamed { old_name: String, new_name: String },\n    FileRemoved { name: String },\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ApiFile {\n    path: String,\n}\n\n#[derive(Serialize, Debug)]\nstruct FilesResponse {\n    files: Vec<ApiFile>,\n}\n\n#[derive(Serialize, Debug)]\nstruct FileContentResponse {\n    markdown: String,\n}\n\n#[derive(Deserialize, Debug)]\nstruct FileUpdateRequest {\n    markdown: String,\n}\n\npub fn scan_markdown_files(dir: &Path) -> Result<Vec<PathBuf>> {\n    let mut md_files = Vec::new();\n    scan_markdown_files_recursive(dir, &mut md_files)?;\n    md_files.sort();\n    Ok(md_files)\n}\n\nfn scan_markdown_files_recursive(dir: &Path, md_files: &mut Vec<PathBuf>) -> Result<()> {\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n\n        if path.is_file() && is_markdown_file(&path) {\n            md_files.push(path);\n        } else if path.is_dir() {\n            scan_markdown_files_recursive(&path, md_files)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn is_markdown_file(path: &Path) -> bool {\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| ext.eq_ignore_ascii_case(\"md\") || ext.eq_ignore_ascii_case(\"markdown\"))\n        .unwrap_or(false)\n}\n\nfn calculate_relative_path(file_path: &Path, base_dir: &Path) -> Result<String> {\n    let canonical_path = file_path.canonicalize()?;\n    let relative_path = canonical_path\n        .strip_prefix(base_dir)\n        .map_err(|_| anyhow::anyhow!(\"File path is not within base directory\"))?\n        .to_string_lossy()\n        .to_string();\n    Ok(relative_path)\n}\n\nstruct TrackedFile {\n    path: PathBuf,\n    last_modified: SystemTime,\n    markdown: String,\n    content_hash: md5::Digest,\n}\n\nstruct MarkdownState {\n    base_dir: PathBuf,\n    tracked_files: std::collections::HashMap<String, TrackedFile>,\n    is_directory_mode: bool,\n    change_tx: broadcast::Sender<ServerMessage>,\n}\n\nimpl MarkdownState {\n    fn new(base_dir: PathBuf, file_paths: Vec<PathBuf>, is_directory_mode: bool) -> Result<Self> {\n        let (change_tx, _) = broadcast::channel::<ServerMessage>(16);\n\n        let mut tracked_files = std::collections::HashMap::new();\n        for file_path in file_paths {\n            let metadata = fs::metadata(&file_path)?;\n            let last_modified = metadata.modified()?;\n            let content = fs::read_to_string(&file_path)?;\n            let content_hash = md5::compute(&content);\n            let relative_path = calculate_relative_path(&file_path, &base_dir)?;\n\n            tracked_files.insert(\n                relative_path.clone(),\n                TrackedFile {\n                    path: file_path,\n                    last_modified,\n                    markdown: content,\n                    content_hash,\n                },\n            );\n        }\n\n        Ok(MarkdownState {\n            base_dir,\n            tracked_files,\n            is_directory_mode,\n            change_tx,\n        })\n    }\n\n    fn get_sorted_filenames(&self) -> Vec<String> {\n        let mut filenames: Vec<_> = self.tracked_files.keys().cloned().collect();\n        filenames.sort();\n        filenames\n    }\n\n    fn refresh_file(&mut self, relative_path: &str) -> Result<()> {\n        if let Some(tracked) = self.tracked_files.get_mut(relative_path) {\n            let metadata = fs::metadata(&tracked.path)?;\n            let current_modified = metadata.modified()?;\n\n            if current_modified > tracked.last_modified {\n                let content = fs::read_to_string(&tracked.path)?;\n                tracked.markdown = content;\n                tracked.last_modified = current_modified;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn update_file(&mut self, relative_path: &str, new_content: &str) -> Result<()> {\n        if let Some(tracked) = self.tracked_files.get_mut(relative_path) {\n            fs::write(&tracked.path, new_content)?;\n            tracked.markdown = new_content.to_string();\n            tracked.last_modified = SystemTime::now();\n            tracked.content_hash = md5::compute(new_content.as_bytes());\n            let _ = self.change_tx.send(ServerMessage::Reload);\n        } else {\n            return Err(anyhow::anyhow!(\"File not found: {}\", relative_path));\n        }\n\n        Ok(())\n    }\n\n    fn add_tracked_file(&mut self, file_path: PathBuf) -> Result<()> {\n        let relative_path = calculate_relative_path(&file_path, &self.base_dir)?;\n\n        if self.tracked_files.contains_key(&relative_path) {\n            return Ok(());\n        }\n\n        let metadata = fs::metadata(&file_path)?;\n        let content = fs::read_to_string(&file_path)?;\n        let content_hash = md5::compute(&content);\n\n        self.tracked_files.insert(\n            relative_path.clone(),\n            TrackedFile {\n                path: file_path,\n                last_modified: metadata.modified()?,\n                markdown: content,\n                content_hash,\n            },\n        );\n\n        Ok(())\n    }\n\n    fn rescan_directory(&mut self) -> Result<bool> {\n        if !self.is_directory_mode {\n            return Ok(false);\n        }\n\n        let current_files = scan_markdown_files(&self.base_dir)?;\n        let current_relative_paths: std::collections::HashSet<String> = current_files\n            .iter()\n            .filter_map(|p| {\n                p.canonicalize().ok().and_then(|canonical| {\n                    canonical\n                        .strip_prefix(&self.base_dir)\n                        .ok()\n                        .map(|rel| rel.to_string_lossy().to_string())\n                })\n            })\n            .collect();\n\n        let tracked_relative_paths: std::collections::HashSet<String> =\n            self.tracked_files.keys().cloned().collect();\n\n        if current_relative_paths == tracked_relative_paths {\n            return Ok(false);\n        }\n\n        self.tracked_files\n            .retain(|relative_path, _| current_relative_paths.contains(relative_path));\n\n        for file_path in current_files {\n            let Ok(canonical_path) = file_path.canonicalize() else {\n                continue;\n            };\n            let Ok(rel_path) = canonical_path.strip_prefix(&self.base_dir) else {\n                continue;\n            };\n            let relative_path = rel_path.to_string_lossy().to_string();\n\n            if self.tracked_files.contains_key(&relative_path) {\n                continue;\n            }\n\n            let Ok(metadata) = fs::metadata(&file_path) else {\n                continue;\n            };\n            let Ok(content) = fs::read_to_string(&file_path) else {\n                continue;\n            };\n            let Ok(last_modified) = metadata.modified() else {\n                continue;\n            };\n            let content_hash = md5::compute(&content);\n\n            self.tracked_files.insert(\n                relative_path.clone(),\n                TrackedFile {\n                    path: file_path,\n                    last_modified,\n                    markdown: content,\n                    content_hash,\n                },\n            );\n        }\n\n        Ok(true)\n    }\n}\n\nasync fn handle_markdown_file_change(path: &Path, state: &SharedMarkdownState) {\n    if !is_markdown_file(path) {\n        return;\n    }\n\n    let mut state_guard = state.lock().await;\n\n    let Ok(relative_path) = calculate_relative_path(path, &state_guard.base_dir) else {\n        return;\n    };\n\n    if state_guard.tracked_files.contains_key(&relative_path) {\n        if state_guard.refresh_file(&relative_path).is_ok() {\n            let _ = state_guard.change_tx.send(ServerMessage::Reload);\n        }\n    } else if state_guard.is_directory_mode {\n        if state_guard.add_tracked_file(path.to_path_buf()).is_ok() {\n            let _ = state_guard\n                .change_tx\n                .send(ServerMessage::FileAdded { name: relative_path });\n        }\n    }\n}\n\nenum FileChangeType {\n    Renamed { old_name: String, new_name: String },\n    Removed { name: String },\n    Other,\n}\n\nfn detect_file_change(\n    old_files: &std::collections::HashSet<String>,\n    new_files: &std::collections::HashSet<String>,\n    _old_tracked_files: &std::collections::HashMap<String, md5::Digest>,\n    _new_tracked_files: &std::collections::HashMap<String, TrackedFile>,\n) -> FileChangeType {\n    let added: Vec<_> = new_files.difference(old_files).collect();\n    let removed: Vec<_> = old_files.difference(new_files).collect();\n\n    // If exactly one file was removed and one was added, treat it as a rename\n    // This handles both: (1) actual renames with no content change, and\n    // (2) files that were edited then renamed (content hash differs)\n    if let ([new_name], [old_name]) = (added.as_slice(), removed.as_slice()) {\n        return FileChangeType::Renamed {\n            old_name: (*old_name).clone(),\n            new_name: (*new_name).clone(),\n        };\n    }\n\n    if let Some(&first_removed) = removed.first() {\n        return FileChangeType::Removed {\n            name: first_removed.clone(),\n        };\n    }\n\n    FileChangeType::Other\n}\n\nfn send_change_message(change_type: FileChangeType, tx: &broadcast::Sender<ServerMessage>) {\n    let message = match change_type {\n        FileChangeType::Renamed { old_name, new_name } => {\n            ServerMessage::FileRenamed { old_name, new_name }\n        }\n        FileChangeType::Removed { name } => ServerMessage::FileRemoved { name },\n        FileChangeType::Other => ServerMessage::Reload,\n    };\n\n    let _ = tx.send(message);\n}\n\nasync fn rescan_and_detect_changes(state: &SharedMarkdownState) {\n    let (old_files, old_hashes) = {\n        let guard = state.lock().await;\n        let files = guard.tracked_files.keys().cloned().collect();\n        let hashes: std::collections::HashMap<String, md5::Digest> = guard\n            .tracked_files\n            .iter()\n            .map(|(k, v)| (k.clone(), v.content_hash))\n            .collect();\n        (files, hashes)\n    };\n\n    let mut guard = state.lock().await;\n\n    let Ok(changed) = guard.rescan_directory() else {\n        return;\n    };\n\n    if !changed {\n        return;\n    }\n\n    let new_files: std::collections::HashSet<String> = guard.tracked_files.keys().cloned().collect();\n\n    let change_type = detect_file_change(&old_files, &new_files, &old_hashes, &guard.tracked_files);\n    send_change_message(change_type, &guard.change_tx);\n}\n\nfn schedule_delayed_rescan(state: &SharedMarkdownState) {\n    let state_clone = state.clone();\n    tokio::spawn(async move {\n        tokio::time::sleep(tokio::time::Duration::from_millis(RESCAN_DELAY_MS)).await;\n        rescan_and_detect_changes(&state_clone).await;\n    });\n}\n\nasync fn handle_rename_event(\n    mode: notify::event::RenameMode,\n    paths: &[PathBuf],\n    state: &SharedMarkdownState,\n) {\n    use notify::event::RenameMode;\n\n    let is_dir_mode = state.lock().await.is_directory_mode;\n    if is_dir_mode {\n        schedule_delayed_rescan(state);\n        return;\n    }\n\n    match mode {\n        RenameMode::Both => {\n            let Some(new_path) = paths.get(1) else { return };\n            handle_markdown_file_change(new_path, state).await;\n        }\n        RenameMode::To => {\n            let Some(path) = paths.first() else { return };\n            handle_markdown_file_change(path, state).await;\n        }\n        RenameMode::Any => {\n            let Some(path) = paths.first() else { return };\n            if !path.exists() {\n                return;\n            }\n            handle_markdown_file_change(path, state).await;\n        }\n        RenameMode::From | RenameMode::Other => {}\n    }\n}\n\nasync fn handle_md_create_or_modify(path: &Path, state: &SharedMarkdownState) {\n    handle_markdown_file_change(path, state).await;\n}\n\nasync fn handle_md_remove(_path: &Path, state: &SharedMarkdownState) {\n    let is_dir_mode = state.lock().await.is_directory_mode;\n    if !is_dir_mode {\n        return;\n    }\n\n    schedule_delayed_rescan(state);\n}\n\nasync fn handle_image_change(state: &SharedMarkdownState) {\n    let guard = state.lock().await;\n    let _ = guard.change_tx.send(ServerMessage::Reload);\n}\n\nasync fn handle_file_event(event: Event, state: &SharedMarkdownState) {\n    use notify::event::ModifyKind;\n    use notify::EventKind::{Create, Modify, Remove};\n\n    match event.kind {\n        Modify(ModifyKind::Name(rename_mode)) => {\n            handle_rename_event(rename_mode, &event.paths, state).await;\n        }\n        _ => {\n            for path in &event.paths {\n                if is_markdown_file(path) {\n                    match event.kind {\n                        Create(_) | Modify(ModifyKind::Data(_)) => {\n                            handle_md_create_or_modify(path, state).await;\n                        }\n                        Remove(_) => {\n                            handle_md_remove(path, state).await;\n                        }\n                        _ => {}\n                    }\n                } else if path.is_file() && is_image_file(path.to_str().unwrap_or(\"\")) {\n                    match event.kind {\n                        Modify(_) | Create(_) | Remove(_) => {\n                            handle_image_change(state).await;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n}\n\nasync fn serve_embedded_file(uri: Uri) -> Response {\n    let path = uri.path().trim_start_matches('/');\n\n    // If path is empty or is a directory-like path, serve index.html\n    let file_path = if path.is_empty() || path.ends_with('/') {\n        \"index.html\"\n    } else {\n        path\n    };\n\n    match FrontendAssets::get(file_path) {\n        Some(content) => {\n            let mime = mime_guess::from_path(file_path).first_or_octet_stream();\n            Response::builder()\n                .status(StatusCode::OK)\n                .header(header::CONTENT_TYPE, mime.as_ref())\n                .body(content.data.into())\n                .unwrap()\n        }\n        None => {\n            // For SPA routing: if the file doesn't exist, serve index.html\n            match FrontendAssets::get(\"index.html\") {\n                Some(content) => Response::builder()\n                    .status(StatusCode::OK)\n                    .header(header::CONTENT_TYPE, \"text/html\")\n                    .body(content.data.into())\n                    .unwrap(),\n                None => Response::builder()\n                    .status(StatusCode::NOT_FOUND)\n                    .body(\"404 Not Found\".into())\n                    .unwrap(),\n            }\n        }\n    }\n}\n\npub fn new_router(\n    base_dir: PathBuf,\n    tracked_files: Vec<PathBuf>,\n    is_directory_mode: bool,\n) -> Result<Router> {\n    let base_dir = base_dir.canonicalize()?;\n\n    let state = Arc::new(Mutex::new(MarkdownState::new(\n        base_dir.clone(),\n        tracked_files,\n        is_directory_mode,\n    )?));\n\n    let watcher_state = state.clone();\n    let (tx, mut rx) = mpsc::channel(100);\n\n    let mut watcher = RecommendedWatcher::new(\n        move |res: std::result::Result<Event, notify::Error>| {\n            if let Ok(event) = res {\n                let _ = tx.blocking_send(event);\n            }\n        },\n        Config::default(),\n    )?;\n\n    watcher.watch(&base_dir, RecursiveMode::Recursive)?;\n\n    tokio::spawn(async move {\n        let _watcher = watcher;\n        while let Some(event) = rx.recv().await {\n            handle_file_event(event, &watcher_state).await;\n        }\n    });\n\n    // Create router with embedded frontend assets\n    let api_router = Router::new()\n        .route(\"/api/files\", get(api_get_files))\n        .route(\"/api/files/*path\", get(api_get_file))\n        .route(\"/api/files/*path\", put(api_update_file))\n        .route(\"/api/static/*path\", get(api_serve_static))\n        .route(\"/ws\", get(websocket_handler))\n        .route(\"/__health\", get(server_health))\n        .with_state(state.clone())\n        .fallback(serve_embedded_file);\n\n    Ok(api_router.layer(CorsLayer::permissive()))\n}\n\npub async fn serve_markdown(\n    base_dir: PathBuf,\n    tracked_files: Vec<PathBuf>,\n    is_directory_mode: bool,\n    hostname: impl AsRef<str>,\n    port: u16,\n) -> Result<()> {\n    let hostname = hostname.as_ref();\n\n    let first_file = tracked_files.first().cloned();\n    let router = new_router(base_dir.clone(), tracked_files, is_directory_mode)?;\n\n    let listener = TcpListener::bind((hostname, port)).await?;\n\n    let listen_addr = format_host(hostname, port);\n\n    if is_directory_mode {\n        println!(\"ðŸ“ Serving markdown files from: {}\", base_dir.display());\n    } else if let Some(file_path) = first_file {\n        println!(\"ðŸ“„ Serving markdown file: {}\", file_path.display());\n    }\n\n    println!(\"ðŸŒ Server running at: http://{listen_addr}\");\n    println!(\"âš¡ Live reload enabled\");\n    println!(\"\\nPress Ctrl+C to stop the server\");\n\n    axum::serve(listener, router).await?;\n\n    Ok(())\n}\n\nfn format_host(hostname: &str, port: u16) -> String {\n    if hostname.parse::<Ipv6Addr>().is_ok() {\n        format!(\"[{hostname}]:{port}\")\n    } else {\n        format!(\"{hostname}:{port}\")\n    }\n}\n\nasync fn api_get_files(State(state): State<SharedMarkdownState>) -> Json<FilesResponse> {\n    let state = state.lock().await;\n    let files = state\n        .get_sorted_filenames()\n        .into_iter()\n        .map(|path| ApiFile { path })\n        .collect();\n\n    Json(FilesResponse { files })\n}\n\nasync fn api_get_file(\n    AxumPath(path): AxumPath<String>,\n    State(state): State<SharedMarkdownState>,\n) -> impl IntoResponse {\n    let mut state = state.lock().await;\n\n    if !state.tracked_files.contains_key(&path) {\n        return (\n            StatusCode::NOT_FOUND,\n            Json(serde_json::json!({\"error\": \"File not found\"})),\n        )\n            .into_response();\n    }\n\n    let _ = state.refresh_file(&path);\n\n    if let Some(tracked) = state.tracked_files.get(&path) {\n        Json(FileContentResponse {\n            markdown: tracked.markdown.clone(),\n        })\n        .into_response()\n    } else {\n        (\n            StatusCode::NOT_FOUND,\n            Json(serde_json::json!({\"error\": \"File not found\"})),\n        )\n            .into_response()\n    }\n}\n\nasync fn api_update_file(\n    AxumPath(path): AxumPath<String>,\n    State(state): State<SharedMarkdownState>,\n    Json(request): Json<FileUpdateRequest>,\n) -> impl IntoResponse {\n    let mut state = state.lock().await;\n\n    match state.update_file(&path, &request.markdown) {\n        Ok(()) => (StatusCode::OK, Json(serde_json::json!({\"success\": true}))).into_response(),\n        Err(e) => (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            Json(serde_json::json!({\"error\": e.to_string()})),\n        )\n            .into_response(),\n    }\n}\n\nasync fn api_serve_static(\n    AxumPath(path): AxumPath<String>,\n    State(state): State<SharedMarkdownState>,\n) -> impl IntoResponse {\n    // Only serve image files for security\n    if !is_image_file(&path) {\n        return (\n            StatusCode::NOT_FOUND,\n            [(header::CONTENT_TYPE, \"text/plain\")],\n            \"File not found\".to_string(),\n        )\n            .into_response();\n    }\n\n    let state = state.lock().await;\n\n    let full_path = state.base_dir.join(&path);\n\n    match full_path.canonicalize() {\n        Ok(canonical_path) => {\n            if !canonical_path.starts_with(&state.base_dir) {\n                return (\n                    StatusCode::FORBIDDEN,\n                    [(header::CONTENT_TYPE, \"text/plain\")],\n                    \"Access denied\".to_string(),\n                )\n                    .into_response();\n            }\n\n            match fs::read(&canonical_path) {\n                Ok(contents) => {\n                    let content_type = guess_image_content_type(&path);\n                    (\n                        StatusCode::OK,\n                        [(header::CONTENT_TYPE, content_type.as_str())],\n                        contents,\n                    )\n                        .into_response()\n                }\n                Err(_) => (\n                    StatusCode::NOT_FOUND,\n                    [(header::CONTENT_TYPE, \"text/plain\")],\n                    \"File not found\".to_string(),\n                )\n                    .into_response(),\n            }\n        }\n        Err(_) => (\n            StatusCode::NOT_FOUND,\n            [(header::CONTENT_TYPE, \"text/plain\")],\n            \"File not found\".to_string(),\n        )\n            .into_response(),\n    }\n}\n\nasync fn server_health() -> impl IntoResponse {\n    (StatusCode::OK, \"ready\")\n}\n\nfn is_image_file(file_path: &str) -> bool {\n    let extension = std::path::Path::new(file_path)\n        .extension()\n        .and_then(|ext| ext.to_str())\n        .unwrap_or(\"\");\n\n    matches!(\n        extension.to_lowercase().as_str(),\n        \"png\" | \"jpg\" | \"jpeg\" | \"gif\" | \"svg\" | \"webp\" | \"bmp\" | \"ico\"\n    )\n}\n\nfn guess_image_content_type(file_path: &str) -> String {\n    let extension = std::path::Path::new(file_path)\n        .extension()\n        .and_then(|ext| ext.to_str())\n        .unwrap_or(\"\");\n\n    match extension.to_lowercase().as_str() {\n        \"png\" => \"image/png\",\n        \"jpg\" | \"jpeg\" => \"image/jpeg\",\n        \"gif\" => \"image/gif\",\n        \"svg\" => \"image/svg+xml\",\n        \"webp\" => \"image/webp\",\n        \"bmp\" => \"image/bmp\",\n        \"ico\" => \"image/x-icon\",\n        _ => \"application/octet-stream\",\n    }\n    .to_string()\n}\n\nasync fn websocket_handler(\n    ws: WebSocketUpgrade,\n    State(state): State<SharedMarkdownState>,\n) -> impl IntoResponse {\n    ws.on_upgrade(move |socket| handle_websocket(socket, state))\n}\n\nasync fn handle_websocket(socket: WebSocket, state: SharedMarkdownState) {\n    let (mut sender, mut receiver) = socket.split();\n\n    let mut change_rx = {\n        let state = state.lock().await;\n        state.change_tx.subscribe()\n    };\n\n    let recv_task = tokio::spawn(async move {\n        while let Some(msg) = receiver.next().await {\n            match msg {\n                Ok(Message::Text(text)) => {\n                    if let Ok(client_msg) = serde_json::from_str::<ClientMessage>(&text) {\n                        match client_msg {\n                            ClientMessage::Ping | ClientMessage::RequestRefresh => {}\n                        }\n                    }\n                }\n                Ok(Message::Close(_)) => break,\n                _ => {}\n            }\n        }\n    });\n\n    let send_task = tokio::spawn(async move {\n        while let Ok(reload_msg) = change_rx.recv().await {\n            if let Ok(json) = serde_json::to_string(&reload_msg) {\n                if sender.send(Message::Text(json)).await.is_err() {\n                    break;\n                }\n            }\n        }\n    });\n\n    tokio::select! {\n        _ = recv_task => {},\n        _ = send_task => {},\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_is_markdown_file() {\n        assert!(is_markdown_file(Path::new(\"test.md\")));\n        assert!(is_markdown_file(Path::new(\"/path/to/file.md\")));\n        assert!(is_markdown_file(Path::new(\"test.markdown\")));\n        assert!(is_markdown_file(Path::new(\"test.MD\")));\n        assert!(!is_markdown_file(Path::new(\"test.txt\")));\n    }\n\n    #[test]\n    fn test_is_image_file() {\n        assert!(is_image_file(\"test.png\"));\n        assert!(is_image_file(\"test.jpg\"));\n        assert!(!is_image_file(\"test.txt\"));\n    }\n\n    #[test]\n    fn test_format_host() {\n        assert_eq!(format_host(\"127.0.0.1\", 3000), \"127.0.0.1:3000\");\n        assert_eq!(format_host(\"::1\", 3000), \"[::1]:3000\");\n    }\n\n    #[test]\n    fn test_scan_markdown_files_empty_directory() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let result = scan_markdown_files(temp_dir.path()).expect(\"Failed to scan\");\n        assert_eq!(result.len(), 0);\n    }\n\n    #[test]\n    fn test_scan_markdown_files_with_markdown_files() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n        fs::write(temp_dir.path().join(\"test1.md\"), \"# Test 1\").expect(\"Failed to write\");\n        fs::write(temp_dir.path().join(\"test2.markdown\"), \"# Test 2\").expect(\"Failed to write\");\n        fs::write(temp_dir.path().join(\"test.txt\"), \"text\").expect(\"Failed to write\");\n\n        let result = scan_markdown_files(temp_dir.path()).expect(\"Failed to scan\");\n        assert_eq!(result.len(), 2);\n    }\n\n    #[test]\n    fn test_markdown_state_add_tracked_file() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path.clone()], true)\n                .expect(\"Failed to create state\");\n\n        let new_file = base_dir.join(\"new.md\");\n        fs::write(&new_file, \"# New\").expect(\"Failed to write\");\n\n        state\n            .add_tracked_file(new_file.clone())\n            .expect(\"Failed to add file\");\n\n        let relative_path = \"new.md\";\n        assert!(state.tracked_files.contains_key(relative_path));\n        assert_eq!(state.tracked_files.get(relative_path).unwrap().markdown, \"# New\");\n    }\n\n    #[test]\n    fn test_markdown_state_add_tracked_file_duplicate() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path.clone()], true)\n                .expect(\"Failed to create state\");\n\n        // Adding the same file again should succeed but not duplicate\n        state\n            .add_tracked_file(file_path.clone())\n            .expect(\"Failed to add file\");\n\n        assert_eq!(state.tracked_files.len(), 1);\n    }\n\n    #[test]\n    fn test_markdown_state_update_file() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path.clone()], false)\n                .expect(\"Failed to create state\");\n\n        state\n            .update_file(\"test.md\", \"# Updated\")\n            .expect(\"Failed to update\");\n\n        let content = fs::read_to_string(&file_path).expect(\"Failed to read\");\n        assert_eq!(content, \"# Updated\");\n        assert_eq!(state.tracked_files.get(\"test.md\").unwrap().markdown, \"# Updated\");\n    }\n\n    #[test]\n    fn test_markdown_state_update_file_not_found() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path], false)\n                .expect(\"Failed to create state\");\n\n        let result = state.update_file(\"nonexistent.md\", \"# New\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"File not found\"));\n    }\n\n    #[test]\n    fn test_markdown_state_refresh_file() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path.clone()], false)\n                .expect(\"Failed to create state\");\n\n        // Modify the file externally\n        std::thread::sleep(std::time::Duration::from_millis(10));\n        fs::write(&file_path, \"# Modified\").expect(\"Failed to write\");\n\n        state.refresh_file(\"test.md\").expect(\"Failed to refresh\");\n\n        assert_eq!(state.tracked_files.get(\"test.md\").unwrap().markdown, \"# Modified\");\n    }\n\n    #[test]\n    fn test_markdown_state_rescan_directory() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path], true)\n                .expect(\"Failed to create state\");\n\n        // Add a new file\n        let new_file = base_dir.join(\"new.md\");\n        fs::write(&new_file, \"# New\").expect(\"Failed to write\");\n\n        let changed = state.rescan_directory().expect(\"Failed to rescan\");\n        assert!(changed);\n        assert_eq!(state.tracked_files.len(), 2);\n        assert!(state.tracked_files.contains_key(\"new.md\"));\n    }\n\n    #[test]\n    fn test_markdown_state_rescan_directory_no_changes() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path], true)\n                .expect(\"Failed to create state\");\n\n        let changed = state.rescan_directory().expect(\"Failed to rescan\");\n        assert!(!changed);\n    }\n\n    #[test]\n    fn test_markdown_state_rescan_directory_single_file_mode() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file_path], false)\n                .expect(\"Failed to create state\");\n\n        let changed = state.rescan_directory().expect(\"Failed to rescan\");\n        assert!(!changed);\n    }\n\n    #[test]\n    fn test_markdown_state_rescan_directory_file_removed() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file1 = base_dir.join(\"test1.md\");\n        let file2 = base_dir.join(\"test2.md\");\n        fs::write(&file1, \"# Test 1\").expect(\"Failed to write\");\n        fs::write(&file2, \"# Test 2\").expect(\"Failed to write\");\n\n        let mut state =\n            MarkdownState::new(base_dir.clone(), vec![file1.clone(), file2.clone()], true)\n                .expect(\"Failed to create state\");\n\n        assert_eq!(state.tracked_files.len(), 2);\n\n        // Remove one file\n        fs::remove_file(&file2).expect(\"Failed to remove\");\n\n        let changed = state.rescan_directory().expect(\"Failed to rescan\");\n        assert!(changed);\n        assert_eq!(state.tracked_files.len(), 1);\n        assert!(state.tracked_files.contains_key(\"test1.md\"));\n        assert!(!state.tracked_files.contains_key(\"test2.md\"));\n    }\n\n    #[test]\n    fn test_detect_file_change_rename() {\n        use std::collections::{HashMap, HashSet};\n\n        let mut old_files = HashSet::new();\n        old_files.insert(\"old.md\".to_string());\n\n        let mut new_files = HashSet::new();\n        new_files.insert(\"new.md\".to_string());\n\n        let mut old_tracked = HashMap::new();\n        let hash = md5::compute(b\"content\");\n        old_tracked.insert(\"old.md\".to_string(), hash);\n\n        let mut new_tracked = HashMap::new();\n        new_tracked.insert(\n            \"new.md\".to_string(),\n            TrackedFile {\n                path: PathBuf::from(\"new.md\"),\n                last_modified: SystemTime::now(),\n                markdown: \"content\".to_string(),\n                content_hash: hash,\n            },\n        );\n\n        match detect_file_change(&old_files, &new_files, &old_tracked, &new_tracked) {\n            FileChangeType::Renamed { old_name, new_name } => {\n                assert_eq!(old_name, \"old.md\");\n                assert_eq!(new_name, \"new.md\");\n            }\n            _ => panic!(\"Expected Renamed\"),\n        }\n    }\n\n    #[test]\n    fn test_detect_file_change_removed() {\n        use std::collections::{HashMap, HashSet};\n\n        let mut old_files = HashSet::new();\n        old_files.insert(\"removed.md\".to_string());\n\n        let new_files = HashSet::new();\n        let old_tracked = HashMap::new();\n        let new_tracked = HashMap::new();\n\n        match detect_file_change(&old_files, &new_files, &old_tracked, &new_tracked) {\n            FileChangeType::Removed { name } => {\n                assert_eq!(name, \"removed.md\");\n            }\n            _ => panic!(\"Expected Removed\"),\n        }\n    }\n\n    #[test]\n    fn test_detect_file_change_other() {\n        use std::collections::{HashMap, HashSet};\n\n        let mut old_files = HashSet::new();\n        old_files.insert(\"file1.md\".to_string());\n\n        let mut new_files = HashSet::new();\n        new_files.insert(\"file1.md\".to_string());\n        new_files.insert(\"file2.md\".to_string());\n\n        let old_tracked = HashMap::new();\n        let new_tracked = HashMap::new();\n\n        match detect_file_change(&old_files, &new_files, &old_tracked, &new_tracked) {\n            FileChangeType::Other => {}\n            _ => panic!(\"Expected Other\"),\n        }\n    }\n\n    #[test]\n    fn test_send_change_message_renamed() {\n        let (tx, mut rx) = broadcast::channel(10);\n\n        send_change_message(\n            FileChangeType::Renamed {\n                old_name: \"old.md\".to_string(),\n                new_name: \"new.md\".to_string(),\n            },\n            &tx,\n        );\n\n        match rx.try_recv() {\n            Ok(ServerMessage::FileRenamed { old_name, new_name }) => {\n                assert_eq!(old_name, \"old.md\");\n                assert_eq!(new_name, \"new.md\");\n            }\n            _ => panic!(\"Expected FileRenamed message\"),\n        }\n    }\n\n    #[test]\n    fn test_send_change_message_removed() {\n        let (tx, mut rx) = broadcast::channel(10);\n\n        send_change_message(\n            FileChangeType::Removed {\n                name: \"removed.md\".to_string(),\n            },\n            &tx,\n        );\n\n        match rx.try_recv() {\n            Ok(ServerMessage::FileRemoved { name }) => {\n                assert_eq!(name, \"removed.md\");\n            }\n            _ => panic!(\"Expected FileRemoved message\"),\n        }\n    }\n\n    #[test]\n    fn test_send_change_message_reload() {\n        let (tx, mut rx) = broadcast::channel(10);\n\n        send_change_message(FileChangeType::Other, &tx);\n\n        match rx.try_recv() {\n            Ok(ServerMessage::Reload) => {}\n            _ => panic!(\"Expected Reload message\"),\n        }\n    }\n\n    #[test]\n    fn test_is_image_file_all_types() {\n        // Test all supported image types\n        assert!(is_image_file(\"test.png\"));\n        assert!(is_image_file(\"test.PNG\"));\n        assert!(is_image_file(\"test.jpg\"));\n        assert!(is_image_file(\"test.jpeg\"));\n        assert!(is_image_file(\"test.gif\"));\n        assert!(is_image_file(\"test.svg\"));\n        assert!(is_image_file(\"test.webp\"));\n        assert!(is_image_file(\"test.bmp\"));\n        assert!(is_image_file(\"test.ico\"));\n        // Test non-image files\n        assert!(!is_image_file(\"test.txt\"));\n        assert!(!is_image_file(\"test.md\"));\n        assert!(!is_image_file(\"test\"));\n    }\n\n    #[test]\n    fn test_guess_image_content_type() {\n        assert_eq!(guess_image_content_type(\"test.png\"), \"image/png\");\n        assert_eq!(guess_image_content_type(\"test.jpg\"), \"image/jpeg\");\n        assert_eq!(guess_image_content_type(\"test.jpeg\"), \"image/jpeg\");\n        assert_eq!(guess_image_content_type(\"test.gif\"), \"image/gif\");\n        assert_eq!(guess_image_content_type(\"test.svg\"), \"image/svg+xml\");\n        assert_eq!(guess_image_content_type(\"test.webp\"), \"image/webp\");\n        assert_eq!(guess_image_content_type(\"test.bmp\"), \"image/bmp\");\n        assert_eq!(guess_image_content_type(\"test.ico\"), \"image/x-icon\");\n        assert_eq!(guess_image_content_type(\"test.txt\"), \"application/octet-stream\");\n    }\n\n    #[test]\n    fn test_markdown_state_get_sorted_filenames() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n\n        let file1 = base_dir.join(\"b.md\");\n        let file2 = base_dir.join(\"a.md\");\n        let file3 = base_dir.join(\"c.md\");\n\n        fs::write(&file1, \"# B\").expect(\"Failed to write\");\n        fs::write(&file2, \"# A\").expect(\"Failed to write\");\n        fs::write(&file3, \"# C\").expect(\"Failed to write\");\n\n        let state = MarkdownState::new(\n            base_dir.clone(),\n            vec![file1, file2, file3],\n            true,\n        )\n        .expect(\"Failed to create state\");\n\n        let sorted = state.get_sorted_filenames();\n        assert_eq!(sorted, vec![\"a.md\", \"b.md\", \"c.md\"]);\n    }\n\n    #[test]\n    fn test_calculate_relative_path() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let relative = calculate_relative_path(&file_path, &base_dir)\n            .expect(\"Failed to calculate relative path\");\n        assert_eq!(relative, \"test.md\");\n    }\n\n    #[test]\n    fn test_calculate_relative_path_nested() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let nested_dir = base_dir.join(\"nested\");\n        fs::create_dir(&nested_dir).expect(\"Failed to create nested dir\");\n        let file_path = nested_dir.join(\"test.md\");\n\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let relative = calculate_relative_path(&file_path, &base_dir)\n            .expect(\"Failed to calculate relative path\");\n        assert_eq!(relative, \"nested/test.md\");\n    }\n\n    #[test]\n    fn test_scan_markdown_files_nested() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let nested_dir = temp_dir.path().join(\"nested\");\n        fs::create_dir(&nested_dir).expect(\"Failed to create nested dir\");\n\n        fs::write(temp_dir.path().join(\"root.md\"), \"# Root\").expect(\"Failed to write\");\n        fs::write(nested_dir.join(\"nested.md\"), \"# Nested\").expect(\"Failed to write\");\n\n        let result = scan_markdown_files(temp_dir.path()).expect(\"Failed to scan\");\n        assert_eq!(result.len(), 2);\n    }\n\n    #[test]\n    fn test_markdown_state_refresh_file_not_modified() {\n        let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n        let base_dir = temp_dir.path().canonicalize().expect(\"Failed to canonicalize\");\n        let file_path = base_dir.join(\"test.md\");\n\n        fs::write(&file_path, \"# Test\").expect(\"Failed to write\");\n\n        let mut state = MarkdownState::new(\n            base_dir.clone(),\n            vec![file_path.clone()],\n            false,\n        )\n        .expect(\"Failed to create state\");\n\n        // Get original content\n        let original_content = state.tracked_files.get(\"test.md\").unwrap().markdown.clone();\n\n        // Refresh without modification\n        state.refresh_file(\"test.md\").expect(\"Failed to refresh\");\n\n        // Content should be unchanged\n        assert_eq!(state.tracked_files.get(\"test.md\").unwrap().markdown, original_content);\n    }\n\n    #[test]\n    fn test_format_host_ipv4() {\n        assert_eq!(format_host(\"0.0.0.0\", 8080), \"0.0.0.0:8080\");\n        assert_eq!(format_host(\"192.168.1.1\", 3000), \"192.168.1.1:3000\");\n    }\n\n    #[test]\n    fn test_format_host_ipv6() {\n        assert_eq!(format_host(\"::1\", 3000), \"[::1]:3000\");\n        assert_eq!(format_host(\"fe80::1\", 8080), \"[fe80::1]:8080\");\n    }\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":46}},{"line":75,"address":[],"length":0,"stats":{"Line":92}},{"line":76,"address":[],"length":0,"stats":{"Line":138}},{"line":77,"address":[],"length":0,"stats":{"Line":46}},{"line":78,"address":[],"length":0,"stats":{"Line":46}},{"line":81,"address":[],"length":0,"stats":{"Line":55}},{"line":82,"address":[],"length":0,"stats":{"Line":236}},{"line":83,"address":[],"length":0,"stats":{"Line":252}},{"line":84,"address":[],"length":0,"stats":{"Line":378}},{"line":86,"address":[],"length":0,"stats":{"Line":464}},{"line":87,"address":[],"length":0,"stats":{"Line":208}},{"line":88,"address":[],"length":0,"stats":{"Line":126}},{"line":89,"address":[],"length":0,"stats":{"Line":27}},{"line":93,"address":[],"length":0,"stats":{"Line":55}},{"line":96,"address":[],"length":0,"stats":{"Line":146}},{"line":97,"address":[],"length":0,"stats":{"Line":292}},{"line":98,"address":[],"length":0,"stats":{"Line":438}},{"line":99,"address":[],"length":0,"stats":{"Line":710}},{"line":103,"address":[],"length":0,"stats":{"Line":132}},{"line":104,"address":[],"length":0,"stats":{"Line":396}},{"line":105,"address":[],"length":0,"stats":{"Line":396}},{"line":106,"address":[],"length":0,"stats":{"Line":132}},{"line":107,"address":[],"length":0,"stats":{"Line":132}},{"line":110,"address":[],"length":0,"stats":{"Line":132}},{"line":128,"address":[],"length":0,"stats":{"Line":61}},{"line":129,"address":[],"length":0,"stats":{"Line":122}},{"line":131,"address":[],"length":0,"stats":{"Line":122}},{"line":132,"address":[],"length":0,"stats":{"Line":301}},{"line":133,"address":[],"length":0,"stats":{"Line":360}},{"line":134,"address":[],"length":0,"stats":{"Line":360}},{"line":135,"address":[],"length":0,"stats":{"Line":360}},{"line":136,"address":[],"length":0,"stats":{"Line":360}},{"line":137,"address":[],"length":0,"stats":{"Line":480}},{"line":139,"address":[],"length":0,"stats":{"Line":240}},{"line":140,"address":[],"length":0,"stats":{"Line":240}},{"line":141,"address":[],"length":0,"stats":{"Line":120}},{"line":142,"address":[],"length":0,"stats":{"Line":240}},{"line":143,"address":[],"length":0,"stats":{"Line":240}},{"line":144,"address":[],"length":0,"stats":{"Line":120}},{"line":145,"address":[],"length":0,"stats":{"Line":120}},{"line":150,"address":[],"length":0,"stats":{"Line":61}},{"line":151,"address":[],"length":0,"stats":{"Line":122}},{"line":152,"address":[],"length":0,"stats":{"Line":122}},{"line":153,"address":[],"length":0,"stats":{"Line":61}},{"line":154,"address":[],"length":0,"stats":{"Line":61}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":159,"address":[],"length":0,"stats":{"Line":30}},{"line":160,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":164,"address":[],"length":0,"stats":{"Line":14}},{"line":165,"address":[],"length":0,"stats":{"Line":42}},{"line":166,"address":[],"length":0,"stats":{"Line":42}},{"line":167,"address":[],"length":0,"stats":{"Line":42}},{"line":169,"address":[],"length":0,"stats":{"Line":14}},{"line":170,"address":[],"length":0,"stats":{"Line":15}},{"line":171,"address":[],"length":0,"stats":{"Line":10}},{"line":172,"address":[],"length":0,"stats":{"Line":5}},{"line":176,"address":[],"length":0,"stats":{"Line":14}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":27}},{"line":181,"address":[],"length":0,"stats":{"Line":21}},{"line":182,"address":[],"length":0,"stats":{"Line":21}},{"line":183,"address":[],"length":0,"stats":{"Line":7}},{"line":184,"address":[],"length":0,"stats":{"Line":14}},{"line":185,"address":[],"length":0,"stats":{"Line":14}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":8}},{"line":196,"address":[],"length":0,"stats":{"Line":6}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":3}},{"line":201,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":9}},{"line":223,"address":[],"length":0,"stats":{"Line":9}},{"line":225,"address":[],"length":0,"stats":{"Line":7}},{"line":226,"address":[],"length":0,"stats":{"Line":16}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":228,"address":[],"length":0,"stats":{"Line":4}},{"line":229,"address":[],"length":0,"stats":{"Line":4}},{"line":230,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":12}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":11}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":246,"address":[],"length":0,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":9}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":9}},{"line":254,"address":[],"length":0,"stats":{"Line":9}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":16}},{"line":285,"address":[],"length":0,"stats":{"Line":8}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":16}},{"line":291,"address":[],"length":0,"stats":{"Line":24}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":24}},{"line":296,"address":[],"length":0,"stats":{"Line":32}},{"line":297,"address":[],"length":0,"stats":{"Line":16}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":3}},{"line":320,"address":[],"length":0,"stats":{"Line":18}},{"line":321,"address":[],"length":0,"stats":{"Line":18}},{"line":326,"address":[],"length":0,"stats":{"Line":11}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":6}},{"line":344,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":6}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":16}},{"line":424,"address":[],"length":0,"stats":{"Line":24}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":32}},{"line":445,"address":[],"length":0,"stats":{"Line":12}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":48}},{"line":451,"address":[],"length":0,"stats":{"Line":32}},{"line":452,"address":[],"length":0,"stats":{"Line":12}},{"line":454,"address":[],"length":0,"stats":{"Line":24}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":8}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":44}},{"line":475,"address":[],"length":0,"stats":{"Line":66}},{"line":478,"address":[],"length":0,"stats":{"Line":98}},{"line":479,"address":[],"length":0,"stats":{"Line":6}},{"line":481,"address":[],"length":0,"stats":{"Line":16}},{"line":484,"address":[],"length":0,"stats":{"Line":22}},{"line":485,"address":[],"length":0,"stats":{"Line":10}},{"line":486,"address":[],"length":0,"stats":{"Line":30}},{"line":487,"address":[],"length":0,"stats":{"Line":10}},{"line":488,"address":[],"length":0,"stats":{"Line":10}},{"line":489,"address":[],"length":0,"stats":{"Line":40}},{"line":490,"address":[],"length":0,"stats":{"Line":30}},{"line":495,"address":[],"length":0,"stats":{"Line":12}},{"line":496,"address":[],"length":0,"stats":{"Line":24}},{"line":497,"address":[],"length":0,"stats":{"Line":12}},{"line":498,"address":[],"length":0,"stats":{"Line":24}},{"line":499,"address":[],"length":0,"stats":{"Line":36}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":50}},{"line":515,"address":[],"length":0,"stats":{"Line":100}},{"line":517,"address":[],"length":0,"stats":{"Line":200}},{"line":518,"address":[],"length":0,"stats":{"Line":100}},{"line":519,"address":[],"length":0,"stats":{"Line":50}},{"line":520,"address":[],"length":0,"stats":{"Line":50}},{"line":523,"address":[],"length":0,"stats":{"Line":150}},{"line":524,"address":[],"length":0,"stats":{"Line":150}},{"line":527,"address":[],"length":0,"stats":{"Line":16}},{"line":528,"address":[],"length":0,"stats":{"Line":48}},{"line":529,"address":[],"length":0,"stats":{"Line":32}},{"line":532,"address":[],"length":0,"stats":{"Line":50}},{"line":535,"address":[],"length":0,"stats":{"Line":200}},{"line":537,"address":[],"length":0,"stats":{"Line":58}},{"line":538,"address":[],"length":0,"stats":{"Line":16}},{"line":539,"address":[],"length":0,"stats":{"Line":88}},{"line":540,"address":[],"length":0,"stats":{"Line":48}},{"line":545,"address":[],"length":0,"stats":{"Line":100}},{"line":546,"address":[],"length":0,"stats":{"Line":150}},{"line":547,"address":[],"length":0,"stats":{"Line":150}},{"line":548,"address":[],"length":0,"stats":{"Line":150}},{"line":549,"address":[],"length":0,"stats":{"Line":150}},{"line":550,"address":[],"length":0,"stats":{"Line":150}},{"line":551,"address":[],"length":0,"stats":{"Line":150}},{"line":552,"address":[],"length":0,"stats":{"Line":150}},{"line":553,"address":[],"length":0,"stats":{"Line":50}},{"line":555,"address":[],"length":0,"stats":{"Line":100}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":6}},{"line":590,"address":[],"length":0,"stats":{"Line":12}},{"line":591,"address":[],"length":0,"stats":{"Line":6}},{"line":593,"address":[],"length":0,"stats":{"Line":6}},{"line":597,"address":[],"length":0,"stats":{"Line":8}},{"line":598,"address":[],"length":0,"stats":{"Line":8}},{"line":599,"address":[],"length":0,"stats":{"Line":8}},{"line":602,"address":[],"length":0,"stats":{"Line":28}},{"line":605,"address":[],"length":0,"stats":{"Line":4}},{"line":608,"address":[],"length":0,"stats":{"Line":6}},{"line":612,"address":[],"length":0,"stats":{"Line":12}},{"line":614,"address":[],"length":0,"stats":{"Line":12}},{"line":615,"address":[],"length":0,"stats":{"Line":2}},{"line":616,"address":[],"length":0,"stats":{"Line":2}},{"line":617,"address":[],"length":0,"stats":{"Line":2}},{"line":619,"address":[],"length":0,"stats":{"Line":2}},{"line":622,"address":[],"length":0,"stats":{"Line":8}},{"line":624,"address":[],"length":0,"stats":{"Line":12}},{"line":625,"address":[],"length":0,"stats":{"Line":4}},{"line":626,"address":[],"length":0,"stats":{"Line":4}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":8}},{"line":643,"address":[],"length":0,"stats":{"Line":16}},{"line":645,"address":[],"length":0,"stats":{"Line":24}},{"line":646,"address":[],"length":0,"stats":{"Line":12}},{"line":647,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":2}},{"line":649,"address":[],"length":0,"stats":{"Line":6}},{"line":655,"address":[],"length":0,"stats":{"Line":16}},{"line":660,"address":[],"length":0,"stats":{"Line":16}},{"line":661,"address":[],"length":0,"stats":{"Line":2}},{"line":662,"address":[],"length":0,"stats":{"Line":2}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[],"length":0,"stats":{"Line":2}},{"line":666,"address":[],"length":0,"stats":{"Line":2}},{"line":669,"address":[],"length":0,"stats":{"Line":28}},{"line":671,"address":[],"length":0,"stats":{"Line":42}},{"line":673,"address":[],"length":0,"stats":{"Line":14}},{"line":674,"address":[],"length":0,"stats":{"Line":12}},{"line":675,"address":[],"length":0,"stats":{"Line":24}},{"line":676,"address":[],"length":0,"stats":{"Line":2}},{"line":677,"address":[],"length":0,"stats":{"Line":2}},{"line":678,"address":[],"length":0,"stats":{"Line":4}},{"line":679,"address":[],"length":0,"stats":{"Line":2}},{"line":681,"address":[],"length":0,"stats":{"Line":2}},{"line":684,"address":[],"length":0,"stats":{"Line":10}},{"line":685,"address":[],"length":0,"stats":{"Line":10}},{"line":686,"address":[],"length":0,"stats":{"Line":30}},{"line":688,"address":[],"length":0,"stats":{"Line":10}},{"line":689,"address":[],"length":0,"stats":{"Line":20}},{"line":690,"address":[],"length":0,"stats":{"Line":10}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":2}},{"line":703,"address":[],"length":0,"stats":{"Line":2}},{"line":704,"address":[],"length":0,"stats":{"Line":4}},{"line":705,"address":[],"length":0,"stats":{"Line":2}},{"line":711,"address":[],"length":0,"stats":{"Line":4}},{"line":712,"address":[],"length":0,"stats":{"Line":2}},{"line":715,"address":[],"length":0,"stats":{"Line":31}},{"line":716,"address":[],"length":0,"stats":{"Line":62}},{"line":718,"address":[],"length":0,"stats":{"Line":91}},{"line":721,"address":[],"length":0,"stats":{"Line":25}},{"line":722,"address":[],"length":0,"stats":{"Line":31}},{"line":727,"address":[],"length":0,"stats":{"Line":19}},{"line":728,"address":[],"length":0,"stats":{"Line":38}},{"line":730,"address":[],"length":0,"stats":{"Line":57}},{"line":733,"address":[],"length":0,"stats":{"Line":19}},{"line":734,"address":[],"length":0,"stats":{"Line":22}},{"line":735,"address":[],"length":0,"stats":{"Line":33}},{"line":736,"address":[],"length":0,"stats":{"Line":15}},{"line":737,"address":[],"length":0,"stats":{"Line":12}},{"line":738,"address":[],"length":0,"stats":{"Line":9}},{"line":739,"address":[],"length":0,"stats":{"Line":4}},{"line":740,"address":[],"length":0,"stats":{"Line":3}},{"line":741,"address":[],"length":0,"stats":{"Line":1}},{"line":746,"address":[],"length":0,"stats":{"Line":8}},{"line":750,"address":[],"length":0,"stats":{"Line":40}},{"line":753,"address":[],"length":0,"stats":{"Line":16}},{"line":754,"address":[],"length":0,"stats":{"Line":24}},{"line":756,"address":[],"length":0,"stats":{"Line":8}},{"line":757,"address":[],"length":0,"stats":{"Line":16}},{"line":758,"address":[],"length":0,"stats":{"Line":16}},{"line":761,"address":[],"length":0,"stats":{"Line":24}},{"line":762,"address":[],"length":0,"stats":{"Line":24}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":24}},{"line":778,"address":[],"length":0,"stats":{"Line":64}},{"line":779,"address":[],"length":0,"stats":{"Line":20}},{"line":780,"address":[],"length":0,"stats":{"Line":50}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":8}},{"line":788,"address":[],"length":0,"stats":{"Line":8}},{"line":789,"address":[],"length":0,"stats":{"Line":8}}],"covered":281,"coverable":376},{"path":["/","Users","stefano","Documents","mdserve","src","lib.rs"],"content":"// Minimal lib.rs to support integration tests\npub mod app;\npub use app::{new_router, scan_markdown_files, serve_markdown, ServerMessage};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stefano","Documents","mdserve","src","main.rs"],"content":"use anyhow::Result;\nuse clap::Parser;\nuse std::path::PathBuf;\n\nuse mdserve::{scan_markdown_files, serve_markdown};\n\n#[derive(Parser)]\n#[command(name = \"mdserve\")]\n#[command(about = \"A simple HTTP server for markdown preview\")]\n#[command(version)]\nstruct Args {\n    /// Path to markdown file or directory to serve\n    path: PathBuf,\n\n    /// Hostname (domain or IP address) to listen on\n    #[arg(short = 'H', long, default_value = \"127.0.0.1\")]\n    hostname: String,\n\n    /// Port to serve on\n    #[arg(short, long, default_value = \"3000\")]\n    port: u16,\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let args = Args::parse();\n    let absolute_path = args.path.canonicalize().unwrap_or(args.path);\n\n    let (base_dir, tracked_files, is_directory_mode) = if absolute_path.is_file() {\n        // Single-file mode: derive parent directory\n        let base_dir = absolute_path\n            .parent()\n            .unwrap_or_else(|| std::path::Path::new(\".\"))\n            .to_path_buf();\n        let tracked_files = vec![absolute_path];\n        (base_dir, tracked_files, false)\n    } else if absolute_path.is_dir() {\n        // Directory mode: scan directory for markdown files\n        let tracked_files = scan_markdown_files(&absolute_path)?;\n        if tracked_files.is_empty() {\n            anyhow::bail!(\"No markdown files found in directory\");\n        }\n        (absolute_path, tracked_files, true)\n    } else {\n        anyhow::bail!(\"Path must be a file or directory\");\n    };\n\n    // Single unified serve function\n    serve_markdown(\n        base_dir,\n        tracked_files,\n        is_directory_mode,\n        args.hostname,\n        args.port,\n    )\n    .await?;\n\n    Ok(())\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","Users","stefano","Documents","mdserve","tests","integration_test.rs"],"content":"use axum_test::TestServer;\nuse mdserve::{new_router, scan_markdown_files, ServerMessage};\nuse std::fs;\nuse std::time::Duration;\nuse tempfile::{tempdir, Builder, NamedTempFile, TempDir};\n\nconst WEBSOCKET_TIMEOUT_SECS: u64 = 5;\n\nconst TEST_FILE_1_CONTENT: &str = \"# Test 1\\n\\nContent of test1\";\nconst TEST_FILE_2_CONTENT: &str = \"# Test 2\\n\\nContent of test2\";\nconst TEST_FILE_3_CONTENT: &str = \"# Test 3\\n\\nContent of test3\";\n\nfn create_test_server_impl(content: &str, use_http: bool) -> (TestServer, NamedTempFile) {\n    let temp_file = Builder::new()\n        .suffix(\".md\")\n        .tempfile()\n        .expect(\"Failed to create temp file\");\n    fs::write(&temp_file, content).expect(\"Failed to write temp file\");\n\n    let canonical_path = temp_file\n        .path()\n        .canonicalize()\n        .unwrap_or_else(|_| temp_file.path().to_path_buf());\n\n    let base_dir = canonical_path\n        .parent()\n        .unwrap_or_else(|| std::path::Path::new(\".\"))\n        .to_path_buf();\n    let tracked_files = vec![canonical_path];\n    let is_directory_mode = false;\n\n    let router =\n        new_router(base_dir, tracked_files, is_directory_mode).expect(\"Failed to create router\");\n\n    let server = if use_http {\n        TestServer::builder()\n            .http_transport()\n            .build(router)\n            .expect(\"Failed to create test server\")\n    } else {\n        TestServer::new(router).expect(\"Failed to create test server\")\n    };\n\n    (server, temp_file)\n}\n\nasync fn create_test_server(content: &str) -> (TestServer, NamedTempFile) {\n    create_test_server_impl(content, false)\n}\n\nasync fn create_test_server_with_http(content: &str) -> (TestServer, NamedTempFile) {\n    create_test_server_impl(content, true)\n}\n\nfn create_directory_server_impl(use_http: bool) -> (TestServer, TempDir) {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    fs::write(temp_dir.path().join(\"test1.md\"), TEST_FILE_1_CONTENT)\n        .expect(\"Failed to write test1.md\");\n    fs::write(temp_dir.path().join(\"test2.markdown\"), TEST_FILE_2_CONTENT)\n        .expect(\"Failed to write test2.markdown\");\n    fs::write(temp_dir.path().join(\"test3.md\"), TEST_FILE_3_CONTENT)\n        .expect(\"Failed to write test3.md\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan markdown files\");\n    let is_directory_mode = true;\n\n    let router =\n        new_router(base_dir, tracked_files, is_directory_mode).expect(\"Failed to create router\");\n\n    let server = if use_http {\n        TestServer::builder()\n            .http_transport()\n            .build(router)\n            .expect(\"Failed to create test server\")\n    } else {\n        TestServer::new(router).expect(\"Failed to create test server\")\n    };\n\n    (server, temp_dir)\n}\n\nasync fn create_directory_server() -> (TestServer, TempDir) {\n    create_directory_server_impl(false)\n}\n\nasync fn create_directory_server_with_http() -> (TestServer, TempDir) {\n    create_directory_server_impl(true)\n}\n\n#[tokio::test]\nasync fn test_websocket_connection() {\n    let (server, _temp_file) = create_test_server_with_http(\"# WebSocket Test\").await;\n\n    // Test that WebSocket endpoint exists and can be connected to\n    let response = server.get_websocket(\"/ws\").await;\n    response.assert_status_switching_protocols();\n}\n\n#[tokio::test]\nasync fn test_file_modification_updates_via_websocket() {\n    let (server, temp_file) = create_test_server_with_http(\"# Original Content\").await;\n\n    let mut websocket = server.get_websocket(\"/ws\").await.into_websocket().await;\n\n    // Modify the file\n    fs::write(&temp_file, \"# Modified Content\").expect(\"Failed to modify file\");\n\n\n    // Should receive reload signal via WebSocket (with timeout)\n    let update_result = tokio::time::timeout(\n        Duration::from_secs(WEBSOCKET_TIMEOUT_SECS),\n        websocket.receive_json::<ServerMessage>(),\n    )\n    .await;\n\n    match update_result {\n        Ok(update_message) => {\n            if let ServerMessage::Reload = update_message {\n                // Success - we received a reload signal\n            } else {\n                panic!(\"Expected Reload message after file modification\");\n            }\n        }\n        Err(_) => {\n            panic!(\"Timeout waiting for WebSocket update after file modification\");\n        }\n    }\n}\n\n#[tokio::test]\nasync fn test_unknown_routes_serve_spa() {\n    let (server, _temp_file) = create_test_server(\"# SPA Test\").await;\n\n    // With embedded frontend, unknown routes serve the SPA for client-side routing\n    let response = server.get(\"/unknown-route\").await;\n    assert_eq!(response.status_code(), 200);\n\n    let html = response.text();\n    assert!(html.contains(\"<!doctype html>\"), \"Should serve SPA HTML\");\n}\n\n#[tokio::test]\nasync fn test_non_image_files_not_served_via_api() {\n    use tempfile::tempdir;\n\n    // Create a temporary directory\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    // Create a markdown file\n    let md_content = \"# Test\";\n    let md_path = temp_dir.path().join(\"test.md\");\n    fs::write(&md_path, md_content).expect(\"Failed to write markdown file\");\n\n    // Create a non-image file (txt)\n    let txt_path = temp_dir.path().join(\"secret.txt\");\n    fs::write(&txt_path, \"secret content\").expect(\"Failed to write txt file\");\n\n    // Create router with the markdown file (single-file mode)\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = vec![md_path];\n    let is_directory_mode = false;\n    let router =\n        new_router(base_dir, tracked_files, is_directory_mode).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create test server\");\n\n    // Test that non-image files return 404 via API static endpoint\n    let response = server.get(\"/api/static/secret.txt\").await;\n    assert_eq!(response.status_code(), 404, \"Secret files should not be accessible via API\");\n\n    // Accessing non-API routes serves the SPA\n    let response = server.get(\"/secret.txt\").await;\n    assert_eq!(response.status_code(), 200, \"Non-API routes serve the SPA\");\n    assert!(response.text().contains(\"<!doctype html>\"), \"Should serve SPA HTML, not file content\");\n}\n\n// Directory mode tests\n\n#[tokio::test]\nasync fn test_directory_mode_non_api_routes_serve_spa() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    // Non-API routes (even with .md extension) serve the SPA for client-side routing\n    let response = server.get(\"/nonexistent.md\").await;\n    assert_eq!(response.status_code(), 200, \"Non-API routes serve the SPA\");\n\n    let html = response.text();\n    assert!(html.contains(\"<!doctype html>\"), \"Should serve SPA HTML\");\n}\n\n#[tokio::test]\nasync fn test_single_file_mode_no_navigation_sidebar() {\n    let (server, _temp_file) = create_test_server(\"# Single File Test\").await;\n\n    let response = server.get(\"/\").await;\n    assert_eq!(response.status_code(), 200);\n    let body = response.text();\n\n    // Verify no navigation sidebar in single-file mode\n    assert!(!body.contains(r#\"<nav class=\"sidebar\">\"#));\n    assert!(!body.contains(\"<h3>Files</h3>\"));\n    assert!(!body.contains(r#\"<ul class=\"file-list\">\"#));\n}\n\n#[tokio::test]\nasync fn test_directory_mode_websocket_file_modification() {\n    let (server, temp_dir) = create_directory_server_with_http().await;\n\n    let mut websocket = server.get_websocket(\"/ws\").await.into_websocket().await;\n\n    // Modify one of the tracked files\n    let test_file = temp_dir.path().join(\"test1.md\");\n    fs::write(&test_file, \"# Modified Test 1\\n\\nContent has changed\")\n        .expect(\"Failed to modify file\");\n\n\n    // Should receive reload signal via WebSocket\n    let update_result = tokio::time::timeout(\n        Duration::from_secs(WEBSOCKET_TIMEOUT_SECS),\n        websocket.receive_json::<ServerMessage>(),\n    )\n    .await;\n\n    match update_result {\n        Ok(update_message) => {\n            if let ServerMessage::Reload = update_message {\n                // Success - we received a reload signal\n            } else {\n                panic!(\"Expected Reload message after file modification\");\n            }\n        }\n        Err(_) => {\n            panic!(\"Timeout waiting for WebSocket update after file modification\");\n        }\n    }\n}\n\n// File rename and removal tests\n\n#[tokio::test]\nasync fn test_folder_based_routing_404_for_nonexistent_path() {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    let folder1 = temp_dir.path().join(\"folder1\");\n    fs::create_dir(&folder1).expect(\"Failed to create folder1\");\n    fs::write(folder1.join(\"doc.md\"), \"# Doc\").expect(\"Failed to write file\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    \n    let router = new_router(base_dir, tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create test server\");\n\n    // Non-API routes serve the SPA, even for non-existent paths\n    let response = server.get(\"/nonexistent/doc.md\").await;\n    assert_eq!(response.status_code(), 200, \"Non-API routes serve the SPA\");\n\n    let html = response.text();\n    assert!(html.contains(\"<!doctype html>\"), \"Should serve SPA HTML\");\n\n    // Same for non-existent files in existing folders\n    let response = server.get(\"/folder1/nonexistent.md\").await;\n    assert_eq!(response.status_code(), 200, \"Non-API routes serve the SPA\");\n    assert!(response.text().contains(\"<!doctype html>\"), \"Should serve SPA HTML\");\n}\n\n// ===========================\n// Tree Structure Tests\n// ===========================\n\n// ===========================\n// Folder Removal Tests\n// ===========================\n\n// ===========================\n// Root Route Tests\n// ===========================\n\n// ============================================================================\n// React API Tests - GET /api/files\n// ============================================================================\n\n#[tokio::test]\nasync fn test_api_get_files_single_file() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    let response = server.get(\"/api/files\").await;\n\n    assert_eq!(response.status_code(), 200);\n\n    let json = response.json::<serde_json::Value>();\n    let files = json[\"files\"].as_array().expect(\"files should be an array\");\n\n    assert_eq!(files.len(), 3);\n    assert_eq!(files[0][\"path\"], \"test1.md\");\n    assert_eq!(files[1][\"path\"], \"test2.markdown\");\n    assert_eq!(files[2][\"path\"], \"test3.md\");\n}\n\n#[tokio::test]\nasync fn test_api_get_files_nested_folders() {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    // Create folder structure\n    let folder1 = temp_dir.path().join(\"folder1\");\n    fs::create_dir(&folder1).expect(\"Failed to create folder1\");\n    fs::write(folder1.join(\"file1.md\"), \"# File 1\").expect(\"Failed to write file1\");\n\n    let folder2 = temp_dir.path().join(\"folder2\");\n    fs::create_dir(&folder2).expect(\"Failed to create folder2\");\n    fs::write(folder2.join(\"file2.md\"), \"# File 2\").expect(\"Failed to write file2\");\n\n    fs::write(temp_dir.path().join(\"root.md\"), \"# Root\").expect(\"Failed to write root\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    let router = new_router(base_dir, tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create server\");\n\n    let response = server.get(\"/api/files\").await;\n\n    assert_eq!(response.status_code(), 200);\n\n    let json = response.json::<serde_json::Value>();\n    let files = json[\"files\"].as_array().expect(\"files should be an array\");\n\n    assert_eq!(files.len(), 3);\n\n    // Check file paths\n    let paths: Vec<String> = files.iter()\n        .map(|f| f[\"path\"].as_str().unwrap().to_string())\n        .collect();\n\n    assert!(paths.contains(&\"folder1/file1.md\".to_string()) || paths.contains(&\"folder1\\\\file1.md\".to_string()));\n    assert!(paths.contains(&\"folder2/file2.md\".to_string()) || paths.contains(&\"folder2\\\\file2.md\".to_string()));\n    assert!(paths.contains(&\"root.md\".to_string()));\n}\n\n// ============================================================================\n// React API Tests - GET /api/files/:path\n// ============================================================================\n\n#[tokio::test]\nasync fn test_api_get_file_returns_markdown_content() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    let response = server.get(\"/api/files/test1.md\").await;\n\n    assert_eq!(response.status_code(), 200);\n\n    let json = response.json::<serde_json::Value>();\n    assert_eq!(json[\"markdown\"], TEST_FILE_1_CONTENT);\n}\n\n#[tokio::test]\nasync fn test_api_get_file_nested_folder() {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    let folder1 = temp_dir.path().join(\"folder1\");\n    fs::create_dir(&folder1).expect(\"Failed to create folder1\");\n    fs::write(folder1.join(\"nested.md\"), \"# Nested File\").expect(\"Failed to write nested\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    let router = new_router(base_dir, tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create server\");\n\n    // Try both path separators\n    let response = server.get(\"/api/files/folder1/nested.md\").await;\n\n    if response.status_code() != 200 {\n        // Try Windows-style path\n        let response = server.get(\"/api/files/folder1\\\\nested.md\").await;\n        assert_eq!(response.status_code(), 200);\n        let json = response.json::<serde_json::Value>();\n        assert_eq!(json[\"markdown\"], \"# Nested File\");\n    } else {\n        let json = response.json::<serde_json::Value>();\n        assert_eq!(json[\"markdown\"], \"# Nested File\");\n    }\n}\n\n#[tokio::test]\nasync fn test_api_get_file_not_found() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    let response = server.get(\"/api/files/nonexistent.md\").await;\n\n    assert_eq!(response.status_code(), 404);\n}\n\n// ============================================================================\n// React API Tests - PUT /api/files/:path\n// ============================================================================\n\n#[tokio::test]\nasync fn test_api_update_file_success() {\n    let (server, temp_dir) = create_directory_server().await;\n\n    let update_payload = serde_json::json!({\n        \"markdown\": \"# Updated Content\\n\\nThis is new content\"\n    });\n\n    let response = server.put(\"/api/files/test1.md\")\n        .json(&update_payload)\n        .await;\n\n    assert_eq!(response.status_code(), 200);\n\n    let json = response.json::<serde_json::Value>();\n    assert_eq!(json[\"success\"], true);\n\n    // Verify file was actually updated on disk\n    let file_content = fs::read_to_string(temp_dir.path().join(\"test1.md\"))\n        .expect(\"Failed to read updated file\");\n    assert_eq!(file_content, \"# Updated Content\\n\\nThis is new content\");\n}\n\n#[tokio::test]\nasync fn test_api_update_file_checkbox() {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    let checkbox_content = \"# Todo List\\n\\n- [ ] Task 1\\n- [ ] Task 2\\n- [ ] Task 3\";\n    fs::write(temp_dir.path().join(\"todo.md\"), checkbox_content).expect(\"Failed to write todo\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    let router = new_router(base_dir.clone(), tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create server\");\n\n    // Update first checkbox to checked\n    let updated_content = \"# Todo List\\n\\n- [x] Task 1\\n- [ ] Task 2\\n- [ ] Task 3\";\n    let update_payload = serde_json::json!({\n        \"markdown\": updated_content\n    });\n\n    let response = server.put(\"/api/files/todo.md\")\n        .json(&update_payload)\n        .await;\n\n    assert_eq!(response.status_code(), 200);\n\n    // Verify file was updated\n    let file_content = fs::read_to_string(temp_dir.path().join(\"todo.md\"))\n        .expect(\"Failed to read updated file\");\n    assert_eq!(file_content, updated_content);\n}\n\n#[tokio::test]\nasync fn test_api_update_file_triggers_websocket_reload() {\n    let (server, temp_dir) = create_directory_server_with_http().await;\n\n    let mut websocket = server.get_websocket(\"/ws\").await.into_websocket().await;\n\n    // Update file via API\n    let update_payload = serde_json::json!({\n        \"markdown\": \"# Updated via API\"\n    });\n\n    let response = server.put(\"/api/files/test1.md\")\n        .json(&update_payload)\n        .await;\n\n    assert_eq!(response.status_code(), 200);\n\n    // Should receive reload signal via WebSocket\n    let update_result = tokio::time::timeout(\n        Duration::from_secs(WEBSOCKET_TIMEOUT_SECS),\n        websocket.receive_json::<ServerMessage>(),\n    )\n    .await;\n\n    match update_result {\n        Ok(update_message) => {\n            assert_eq!(update_message, ServerMessage::Reload);\n        }\n        Err(_) => {\n            panic!(\"Timeout waiting for WebSocket reload after API update\");\n        }\n    }\n\n    // Verify file was actually updated\n    let file_content = fs::read_to_string(temp_dir.path().join(\"test1.md\"))\n        .expect(\"Failed to read updated file\");\n    assert_eq!(file_content, \"# Updated via API\");\n}\n\n#[tokio::test]\nasync fn test_api_update_file_not_found() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    let update_payload = serde_json::json!({\n        \"markdown\": \"# New Content\"\n    });\n\n    let response = server.put(\"/api/files/nonexistent.md\")\n        .json(&update_payload)\n        .await;\n\n    assert_eq!(response.status_code(), 500);\n\n    let json = response.json::<serde_json::Value>();\n    assert!(json[\"error\"].as_str().unwrap().contains(\"not found\"));\n}\n\n#[tokio::test]\nasync fn test_frontend_served_from_embedded_assets() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    // Test that the root path serves the frontend index.html\n    let response = server.get(\"/\").await;\n    assert_eq!(response.status_code(), 200);\n\n    let html = response.text();\n    // Verify it's HTML and not an error message\n    assert!(html.contains(\"<!doctype html>\"), \"Should serve HTML, not an error\");\n    assert!(html.contains(\"<div id=\\\"root\\\"></div>\"), \"Should contain React root element\");\n    assert!(!html.contains(\"Frontend not built\"), \"Should not show 'Frontend not built' error\");\n\n    // Verify the HTML references CSS and JS assets\n    assert!(html.contains(\".css\"), \"Should reference CSS files\");\n    assert!(html.contains(\".js\"), \"Should reference JavaScript files\");\n}\n\n#[tokio::test]\nasync fn test_frontend_assets_accessible() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    // First get the index.html to find asset paths\n    let response = server.get(\"/\").await;\n    let html = response.text();\n\n    // Extract a CSS file path from the HTML\n    // Looking for something like: href=\"/assets/index-ASLLX56R.css\"\n    let css_start = html.find(\"href=\\\"/assets/\").unwrap();\n    let css_path_start = css_start + 6; // Skip 'href=\"'\n    let css_end = html[css_path_start..].find(\"\\\"\").unwrap();\n    let css_path = &html[css_path_start..css_path_start + css_end];\n\n    // Test that CSS asset is accessible\n    let css_response = server.get(css_path).await;\n    assert_eq!(css_response.status_code(), 200, \"CSS asset should be accessible\");\n    assert_eq!(css_response.header(\"content-type\"), \"text/css\", \"CSS should have correct MIME type\");\n\n    // Extract a JS file path from the HTML\n    // Looking for something like: src=\"/assets/index-DUnTVOz5.js\"\n    let js_start = html.find(\"src=\\\"/assets/\").unwrap();\n    let js_path_start = js_start + 5; // Skip 'src=\"'\n    let js_end = html[js_path_start..].find(\"\\\"\").unwrap();\n    let js_path = &html[js_path_start..js_path_start + js_end];\n\n    // Test that JS asset is accessible\n    let js_response = server.get(js_path).await;\n    assert_eq!(js_response.status_code(), 200, \"JS asset should be accessible\");\n    assert_eq!(js_response.header(\"content-type\"), \"text/javascript\", \"JS should have correct MIME type\");\n}\n\n#[tokio::test]\nasync fn test_frontend_spa_routing() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    // Test that unknown routes serve index.html for SPA routing\n    let response = server.get(\"/some/unknown/route\").await;\n    assert_eq!(response.status_code(), 200);\n\n    let html = response.text();\n    // Should serve the same index.html for SPA client-side routing\n    assert!(html.contains(\"<!doctype html>\"), \"Unknown routes should serve HTML for SPA routing\");\n    assert!(html.contains(\"<div id=\\\"root\\\"></div>\"), \"Should contain React root element\");\n}\n\n// ============================================================================\n// Health Endpoint Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_health_endpoint() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    let response = server.get(\"/__health\").await;\n\n    assert_eq!(response.status_code(), 200);\n    assert_eq!(response.text(), \"ready\");\n}\n\n// ============================================================================\n// API Static File Serving Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_api_static_serves_image_successfully() {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    // Create a test markdown file\n    fs::write(temp_dir.path().join(\"test.md\"), \"# Test\").expect(\"Failed to write markdown\");\n\n    // Create a test image file (simple PNG header)\n    let png_bytes = vec![0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]; // PNG magic bytes\n    fs::write(temp_dir.path().join(\"test.png\"), &png_bytes).expect(\"Failed to write image\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    let router = new_router(base_dir, tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create server\");\n\n    // Test that image is served successfully\n    let response = server.get(\"/api/static/test.png\").await;\n    assert_eq!(response.status_code(), 200);\n    assert_eq!(response.header(\"content-type\"), \"image/png\");\n    assert_eq!(response.as_bytes(), &png_bytes);\n}\n\n#[tokio::test]\nasync fn test_api_static_path_traversal_blocked() {\n    use std::os::unix::fs::symlink;\n\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    // Create a markdown file in the temp dir\n    fs::write(temp_dir.path().join(\"test.md\"), \"# Test\").expect(\"Failed to write markdown\");\n\n    // Create a \"secret\" file outside the base directory (in parent)\n    let parent_dir = temp_dir.path().parent().unwrap();\n    let secret_file = parent_dir.join(\"secret_image.png\");\n    fs::write(&secret_file, \"SECRET DATA\").expect(\"Failed to write secret file\");\n\n    // Create a symlink inside base_dir that points to the secret file outside\n    let symlink_path = temp_dir.path().join(\"link_to_secret.png\");\n    symlink(&secret_file, &symlink_path).expect(\"Failed to create symlink\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    let router = new_router(base_dir, tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create server\");\n\n    // Try to access file outside base directory via symlink\n    let response = server.get(\"/api/static/link_to_secret.png\").await;\n    assert_eq!(response.status_code(), 403, \"Symlink to file outside base dir should be blocked with 403 Forbidden\");\n    assert_eq!(response.text(), \"Access denied\");\n\n    // Cleanup\n    fs::remove_file(&symlink_path).ok();\n    fs::remove_file(&secret_file).ok();\n}\n\n#[tokio::test]\nasync fn test_api_static_nonexistent_image_returns_404() {\n    let (server, _temp_dir) = create_directory_server().await;\n\n    // Request a non-existent image file\n    let response = server.get(\"/api/static/nonexistent.png\").await;\n    assert_eq!(response.status_code(), 404);\n    assert_eq!(response.text(), \"File not found\");\n}\n\n#[tokio::test]\nasync fn test_api_static_supports_multiple_image_formats() {\n    let temp_dir = tempdir().expect(\"Failed to create temp dir\");\n\n    fs::write(temp_dir.path().join(\"test.md\"), \"# Test\").expect(\"Failed to write markdown\");\n\n    // Create test images for different formats\n    fs::write(temp_dir.path().join(\"test.jpg\"), \"JPEG data\").expect(\"Failed to write jpg\");\n    fs::write(temp_dir.path().join(\"test.gif\"), \"GIF data\").expect(\"Failed to write gif\");\n    fs::write(temp_dir.path().join(\"test.svg\"), \"SVG data\").expect(\"Failed to write svg\");\n    fs::write(temp_dir.path().join(\"test.webp\"), \"WEBP data\").expect(\"Failed to write webp\");\n\n    let base_dir = temp_dir.path().to_path_buf();\n    let tracked_files = scan_markdown_files(&base_dir).expect(\"Failed to scan\");\n    let router = new_router(base_dir, tracked_files, true).expect(\"Failed to create router\");\n    let server = TestServer::new(router).expect(\"Failed to create server\");\n\n    // Test JPG\n    let response = server.get(\"/api/static/test.jpg\").await;\n    assert_eq!(response.status_code(), 200);\n    assert_eq!(response.header(\"content-type\"), \"image/jpeg\");\n\n    // Test GIF\n    let response = server.get(\"/api/static/test.gif\").await;\n    assert_eq!(response.status_code(), 200);\n    assert_eq!(response.header(\"content-type\"), \"image/gif\");\n\n    // Test SVG\n    let response = server.get(\"/api/static/test.svg\").await;\n    assert_eq!(response.status_code(), 200);\n    assert_eq!(response.header(\"content-type\"), \"image/svg+xml\");\n\n    // Test WebP\n    let response = server.get(\"/api/static/test.webp\").await;\n    assert_eq!(response.status_code(), 200);\n    assert_eq!(response.header(\"content-type\"), \"image/webp\");\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":70.7808564231738,"covered":281,"coverable":397}